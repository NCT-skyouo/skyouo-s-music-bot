const URL = require('url');
const UTIL = require('./util.js');
const MINIGET = require('miniget');
const SEARCH_V2 = require('./search_v2.js');
const CACHE = new Map();

const main = module.exports = async(searchString, options) => {
  const resp = {};

  options = UTIL.checkArgs(searchString, options);
  resp.query = options.query;
  // Save provided nextpageRef and do the request
  resp.currentRef = options.nextpageRef;

  // Save api key and version
  if (!CACHE.has('key')) {
    const body = await MINIGET(UTIL.buildRef(resp.currentRef, searchString, options), options).text();
    options.key = UTIL.between(body, 'INNERTUBE_API_KEY":"', '"') || UTIL.between(body, 'innertubeApiKey":"', '"');
    if (!options.key) {
      // V1 result
      let res = await main(searchString, options);
      return res;
    }
    options.clientVersion = UTIL.between(body, 'INNERTUBE_CONTEXT_CLIENT_VERSION":"', '"') ||
      UTIL.between(body, 'innertube_context_client_version":"', '"');
    CACHE.set('key', options.key);
    CACHE.set('clientVersion', options.clientVersion);
  } else {
    options.key = CACHE.get('key');
    options.clientVersion = CACHE.get('clientVersion');
  }
  return SEARCH_V2(searchString, options);
};

main.getFilters = async(searchString, options) => {
  if (!searchString || typeof searchString !== 'string') throw new Error('searchString is mandatory');

  // Watch out for previous filter requests
  // in such a case searchString would be an url including `sp` & `search_query` querys
  let prevQuery = URL.parse(searchString, true).query;
  const urlOptions = prevQuery ? Object.assign({}, options, prevQuery) : options;

  const ref = UTIL.buildRef(null, prevQuery.search_query || searchString, urlOptions);
  const body = await MINIGET(ref, options).text();
  const parsed = JSON.parse(body);
  const content = parsed[parsed.length - 1].body.content;
  return UTIL.parseFilters(content);
};
