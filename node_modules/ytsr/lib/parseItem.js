const FS = require('fs');
const URL = require('url');
const PATH = require('path');
const QS = require('querystring');
const UTIL = require('./util.js');
const BASE_URL = 'https://www.youtube.com/results?';

// Start of parsing an item
const main = module.exports = (string, respString, searchString) => {
  const titles = UTIL.between(string, '<div class="', '"');
  const type = UTIL.between(titles, 'yt-lockup yt-lockup-tile yt-lockup-', ' ');
  if (type === 'playlist') {
    if (string.includes('yt-pl-icon-mix')) return parseMix(string);
    return parsePlaylist(string);
  } else if (type === 'channel') {
    return parseChannel(string);
  } else if (type === 'video') {
    return parseVideo(string);
  } else if (type === 'movie-vertical-poster') {
    return parseMovie(string);
  } else if (titles === 'search-refinements') {
    return parseRelatedSearches(string);
  } else if (titles.includes('shelf') && string.includes('<div class="compact-shelf')) {
    return parseShelfCompact(string);
  } else if (titles.includes('shelf') && string.includes('<div class="vertical-shelf">')) {
    return parseShelfVertical(string);
  } else if (string.includes('<div class="display-message">No more results</div>')) {
    return null;
  } else if (string.includes('<div class="emergency-onebox">')) {
    return null;
  } else if (string.includes('<div class="yt-alert-message"')) {
    return null;
  } else if (titles.includes('yt-lockup-clarification')) {
    return null;
  } else {
    const dir = PATH.resolve(__dirname, '../dumps/');
    const file = PATH.resolve(dir, `${Math.random().toString(36).substr(3)}-${Date.now()}.dumb`);
    const cfg = PATH.resolve(__dirname, '../package.json');
    const bugsRef = require(cfg).bugs.url;
    if (!FS.existsSync(dir)) FS.mkdirSync(dir);
    FS.writeFileSync(file, JSON.stringify({ type, searchString, itemString: string, htmlBody: respString }));
    /* eslint-disable no-console */
    console.error(`\n/${'*'.repeat(200)}`);
    console.error(`found an unknown type |${type}|${titles}|`);
    console.error(`pls post the the files in ${dir} to ${bugsRef}`);
    console.error(`${'*'.repeat(200)}\\`);
    /* eslint-enable no-console */
    return null;
  }
};

const parseMix = main.parseMix = string => {
  const thumbnailRaw = UTIL.between(string, 'data-thumb="', '"');
  const thumbnail = thumbnailRaw ? thumbnailRaw : UTIL.between(string, 'src="', '"');
  const plistID = UTIL.removeHtml(UTIL.between(string, 'data-list-id="', '"'));
  const videoID = UTIL.removeHtml(UTIL.between(string, 'data-video-ids="', '"'));
  return {
    type: 'mix',
    title: UTIL.removeHtml(UTIL.between(UTIL.between(string, '<h3 class="yt-lockup-title ">', '</a>'), '>')),
    firstItem: `https://www.youtube.com/watch?v=${videoID}&list=${plistID}`,
    thumbnail: URL.resolve(BASE_URL, UTIL.removeHtml(thumbnail)),
    length: UTIL.removeHtml(UTIL.between(string, '<span class="formatted-video-count-label">', '</span>')),
  };
};

// Parse an item of type playlist
const parsePlaylist = main.parsePlaylist = string => {
  const ownerBox = UTIL.between(string, '<div class="yt-lockup-byline ">', '</div>');
  const thumbnailRaw = UTIL.between(string, 'data-thumb="', '"');
  const thumbnail = thumbnailRaw ? thumbnailRaw : UTIL.between(string, 'src="', '"');
  const cleanID = UTIL.removeHtml(UTIL.between(string, 'href="/playlist?list=', '"'));
  return {
    type: 'playlist',
    title: UTIL.removeHtml(UTIL.between(UTIL.between(string, '<h3 class="yt-lockup-title ">', '</a>'), '>')),
    link: `https://www.youtube.com/playlist?list=${cleanID}`,
    thumbnail: URL.resolve(BASE_URL, UTIL.removeHtml(thumbnail)),

    author: {
      name: UTIL.removeHtml(UTIL.between(ownerBox, '>', '</a>')),
      ref: URL.resolve(BASE_URL, UTIL.removeHtml(UTIL.between(ownerBox, '<a href="', '"'))),
      verified: string.includes('title="Verified"'),
    },

    length: UTIL.removeHtml(UTIL.between(string, '<span class="formatted-video-count-label">', '</span>')),
  };
};

// Parse an item of type channel
const parseChannel = main.parseChannel = string => {
  const avatarRaw = UTIL.between(string, 'data-thumb="', '"');
  const avatar = avatarRaw ? avatarRaw : UTIL.between(string, 'src="', '"');
  const rawDesc = UTIL.between(UTIL.between(string, '<div class="yt-lockup-description', '</div>'), '>');
  const rawFollows = UTIL.between(UTIL.between(string, 'yt-subscriber-count"', '</span>'), '>');
  return {
    type: 'channel',
    name: UTIL.removeHtml(UTIL.between(UTIL.between(string, '<a href="', '</a>'), '>')),
    channel_id: UTIL.between(string, 'data-channel-external-id="', '"'),
    link: URL.resolve(BASE_URL, UTIL.removeHtml(UTIL.between(string, 'href="', '"'))),
    avatar: URL.resolve(BASE_URL, UTIL.removeHtml(avatar)),
    verified: string.includes('title="Verified"') || string.includes('yt-channel-title-autogenerated'),

    followers: Number(rawFollows.replace(/[.,]/g, '')),
    description_short: UTIL.removeHtml(rawDesc) || null,
    videos: Number(UTIL.between(string, '<ul class="yt-lockup-meta-info"><li>', '</li>')
      .split(' ')
      .splice(0, 1)[0]
      .replace(/[.,]/g, ''),
    ),
  };
};

// Parse an item of type video
const parseVideo = main.parseVideo = string => {
  const ownerBox = UTIL.between(string, '<div class="yt-lockup-byline ">', '</div>');
  const metaInfo = UTIL.between(string, '<div class="yt-lockup-meta ">', '</ul>')
    .replace(/<\/li>/g, '')
    .split('<li>')
    .splice(1);
  if (metaInfo.length === 1) metaInfo.unshift(null);
  const live = string.includes('yt-badge-live" >Live now</span>');
  const live_views = metaInfo[0] ? parseInt(metaInfo[0].replace(/[.,]/g, '')) : 0;
  const thumbnailRaw = UTIL.between(string, 'data-thumb="', '"');
  const thumbnail = thumbnailRaw ? thumbnailRaw : UTIL.between(string, 'src="', '"');
  const rawDesc = UTIL.between(UTIL.between(string, '<div class="yt-lockup-description', '</div>'), '>');
  return {
    type: 'video',
    live: live,
    title: UTIL.removeHtml(UTIL.between(UTIL.between(string, '<a href="', '</a>'), '>')),
    link: URL.resolve(BASE_URL, UTIL.removeHtml(UTIL.between(string, 'href="', '"'))),
    thumbnail: URL.resolve(BASE_URL, UTIL.removeHtml(thumbnail)),

    author: {
      name: UTIL.removeHtml(UTIL.between(ownerBox, '>', '</a>')),
      ref: URL.resolve(BASE_URL, UTIL.removeHtml(UTIL.between(ownerBox, '<a href="', '"'))),
      verified: ownerBox.includes('title="Verified"'),
    },

    description: UTIL.removeHtml(rawDesc) || null,
    // eslint-disable-next-line no-extra-parens
    views: live ? live_views : (
      metaInfo[1] ? Number(metaInfo[1].split(' ')[0].replace(/\.|,/g, '')) : null
    ),
    duration: live ? null : UTIL.between(string, '<span class="video-time" aria-hidden="true">', '</span>'),
    uploaded_at: live ? null : metaInfo[0] || null,
  };
};

// Parse am item of type movie
const parseMovie = main.parseMovie = string => {
  const haystack = string.substr(string.lastIndexOf('<div class="yt-lockup-meta"><ul>') + 32);
  const filmMeta = haystack.substr(0, haystack.indexOf('</ul></div>')).split('<li>');
  const authorInfo = `${string.substr(string.lastIndexOf('<a'), string.lastIndexOf('</a>'))}</a>`;
  const rawDesc = UTIL.between(string, 'yt-lockup-description', '</div>').replace(/[^>]+>/, '');
  const rawMeta = UTIL.between(string, '<div class="yt-lockup-meta"><ul><li>', '</li></ul>');
  return {
    type: 'movie',
    title: UTIL.removeHtml(UTIL.between(string, 'dir="ltr">', '</a>')),
    link: URL.resolve(BASE_URL, UTIL.removeHtml(UTIL.between(string, 'href="', '"'))),
    thumbnail: URL.resolve(BASE_URL, UTIL.removeHtml(UTIL.between(string, 'src="', '"'))),

    author: {
      name: UTIL.removeHtml(UTIL.between(authorInfo, '>', '<')),
      ref: URL.resolve(BASE_URL, UTIL.removeHtml(UTIL.between(authorInfo, '<a href="', '"'))),
      verified: string.includes('title="Verified"'),
    },

    description: UTIL.removeHtml(rawDesc) || null,
    meta: UTIL.removeHtml(rawMeta).split(' Â· '),
    actors: filmMeta[1].replace(/<[^>]+>|^[^:]+: /g, '').split(', ').map(a => UTIL.removeHtml(a)),
    director: filmMeta.length > 2 ? UTIL.removeHtml(filmMeta[2].replace(/<[^>]+>|^[^:]+: /g, '')) : null,
    duration: UTIL.between(string, '<span class="video-time" aria-hidden="true">', '</span>'),
  };
};

// Parse an item of type related searches
const parseRelatedSearches = main.parseRelatedSearches = string => {
  const related = string.split('search-refinement').splice(2);
  return {
    type: 'search-refinements',
    entries: related.map(item => ({
      link: URL.resolve(BASE_URL, UTIL.removeHtml(UTIL.between(item, 'href="', '"'))),
      q: QS.parse(UTIL.removeHtml(UTIL.between(item, '/results?', '"'))).search_query || null,
    })),
  };
};

// Horizontal shelf of youtube movie proposals
const parseShelfCompact = main.parseShelfCompact = string => {
  const itemsRaw = string.split('<li class="yt-uix-shelfslider-item').splice(1);
  const items = itemsRaw.map(item => ({
    type: `${UTIL.between(item, ' ', '-')}-short`,
    name: UTIL.removeHtml(UTIL.between(UTIL.between(item, '><a href="', '</a>'), '>', '')),
    ref: URL.resolve(BASE_URL, UTIL.removeHtml(UTIL.between(item, 'href="', '"'))),
    thumbnail: URL.resolve(BASE_URL, UTIL.removeHtml(UTIL.between(item, 'src="', '"'))),
    duration: UTIL.between(item, '"video-time"', '<').replace(/^[^>]+>/, ''),
    price: UTIL.between(item, '<span class="button-label">', '</span>').replace(/^[^ ]+ /, '') || null,
  }));
  return {
    type: 'shelf-compact',
    title: UTIL.removeHtml(UTIL.between(string, '<span class="branded-page-module-title-text">', '</span>')),
    items,
  };
};

// Vertical shelf of youtube video proposals
const parseShelfVertical = main.parseShelfVertical = string => {
  const itemsRaw = string.split('<a aria-hidden="').splice(1);
  return {
    type: 'shelf-vertical',
    title: UTIL.removeHtml(UTIL.between(string, '<span class="branded-page-module-title-text">', '</span>')),
    items: itemsRaw.map(item => parseVideo(item)),
  };
};
